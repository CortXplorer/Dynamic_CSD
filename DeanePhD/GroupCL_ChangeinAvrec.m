function GroupCL_ChangeinAvrec(homedir)

% This script takes *.mat files out of the figs/Group_Avrec folder which is
% generated by the ChangeInAvrec.m script. MAKE SURE you run the Change in
% Avrec script on the current group.m and _DATA.mat so that things match
% up. This script is dynamic in group size but will need tweaking if a
% group is added.

% Normalization of the layer to the highest peak of any pre laser
% measurement in that measurement can be toggled (yesnorm)

%Input:     D:\MyCode\Dynamic_CSD_Analysis\figs\Group_Avrec -> *AvrecAll.mat
%Output:    D:\MyCode\Dynamic_CSD_Analysis\figs\Group_Avrec -> figures and
%           pdfs of full Avrec and layer-wise Avrecs

%% standard operations
warning('OFF');
dbstop if error

% Change directory to your working folder
if ~exist('homedir','var')
    if exist('D:\MyCode\Dynamic_CSD','dir') == 7
        cd('D:\MyCode\Dynamic_CSD');
    elseif exist('D:\Dynamic_CSD_Analysis','dir') == 7
        cd('D:\Dynamic_CSD_Analysis');
    elseif exist('C:\Users\kedea\Documents\Dynamic_CSD_Analysis','dir') == 7
        cd('C:\Users\kedea\Documents\Dynamic_CSD_Analysis')
    end
    
    homedir = pwd;
    addpath(genpath(homedir));
end

layers = {'All', 'I_IIE', 'IVE', 'VE', 'VIE'};
stimlist = [2,5,10,20,40];

%% Group specific calling!

cd (homedir),cd groups
% get active animals lists
run('KIC.m')
KICan = animals;
run('KIT.m')
KITan = animals;
run('KIV.m')
KIVan = animals;
clear animals Cond Layer dB_lev channels
group = {'KIC','KIT','KIV'};
stimtype = {'CL','AM'};

%% Choose Type

yesnorm = 1;            % 1 = normalize to highest Pre peak; 0 = don't


cd (homedir),cd figs,cd Group_Avrec

for istim = 1:length(stimtype)
    if contains(stimtype{istim},'CL')
        load('CL_AvrecAll.mat')
        AvrecAll = CL_AvrecAll; clear CL_AvrecAll
        PeakofPre = CL_PeakofPre; clear CL_PeakofPre
    elseif contains(stimtype{istim},'AM')
        load('AM_AvrecAll.mat')
        AvrecAll = AM_AvrecAll; clear AM_AvrecAll
        PeakofPre = AM_PeakofPre; clear AM_PeakofPre
    end
    
    %% To Norm or not to Norm
    
    % normalize to all stim of a layerwise or full column call to the highest
    % peak of any stimulus (i.e. 2 Hz) of the layer of that animal
    Subject = 0;
    if yesnorm == 1
        for iAn = 1:size(PeakofPre,3)
            if sum(sum(PeakofPre(:,:,iAn))) == 0
                continue
            end
            Subject = Subject + 1;
            for iStim = 1:size(PeakofPre,1)
                for iLay = 1:size(PeakofPre,2)
                    toNormto = PeakofPre(iStim,iLay,iAn);
                    AvrecAll{iStim,iLay,Subject} = AvrecAll{iStim,iLay,iAn}/toNormto;
                end
            end
        end
        % if number of actual animals is less, cut off the end to the correct size
        if Subject < size(PeakofPre,3)
            AvrecAll = AvrecAll(:,:,1:Subject);
        end
    end
    
    %% Split the groups out
    
    % known alphabetical order is also the order the matrix is generate in
    KICgroup = AvrecAll(:,:,1:length(KICan));
    KITgroup = AvrecAll(:,:,length(KICan)+1:length(KICan)+length(KITan));
    KIVgroup = AvrecAll(:,:,length(KICan)+length(KITan)+1:length(KICan)+length(KITan)+length(KIVan));
    
    
    %% stack groups and generate figures
    
    % Note on how groups are currently structure:
    %       KICgroup{stimulus(i.e. 2 Hz),layer(i.e. IV),animal(i.e.KIC02)}...
    %       (condition(i.e. pre-laser),time(ms))
    
    for iLay = 1:length(layers)

        figure('Name',['GA_Avrec_' stimtype{istim} '_' layers{iLay}], 'Position',[5 45 900 800]); %'Position',[-1000 100 800 1100]
        suborder = [1,4,7,10,13];
         
        for iGroup = 1:length(group)
                      
            for iStim = 1:length(stimlist)
                subplot(length(stimlist),length(group),suborder(iStim));
                if iStim == 1
                    title([stimtype{istim} ' ' layers{iLay} ' ' group{iGroup}])
                end
                hold on
                
                if iGroup == 1
                    stackedgroup = vertcat(KICgroup{iStim,iLay,:});
                elseif iGroup == 2
                    stackedgroup = vertcat(KITgroup{iStim,iLay,:});
                elseif iGroup == 3
                    stackedgroup = vertcat(KIVgroup{iStim,iLay,:});
                end
                
                cond1 = stackedgroup(1:5:end,:);
                cond2 = stackedgroup(2:5:end,:);
                % cond3 = stackedgroup(3:5:end,:);
                % cond4 = stackedgroup(4:5:end,:);
                cond5 = stackedgroup(5:5:end,:);
                
                % Pre
                shadedErrorBar(1:size(cond1,2),nanmean(cond1),nanstd(cond1),'lineProps', '-b')
                % post 1
                shadedErrorBar(1:size(cond2,2),nanmean(cond2),nanstd(cond2),'lineProps', '-r')
                % post 4
                shadedErrorBar(1:size(cond5,2),nanmean(cond5),nanstd(cond5),'lineProps', '-y')
                xlim([0 1400])
                ylim([0 1.5])
            end
            suborder = suborder + 1;
            
        end
        %legend('Pre','std','Post1','std','Post4','std');
        h = gcf;
        savefig(h,['GA_Avrec_' stimtype{istim} '_' layers{iLay}],'compact')
        % sometimes pdf makes a funky error
        try
            h.Renderer='Painters';
            saveas(h,['GA_Avrec_' stimtype{istim} '_'  layers{iLay} '.pdf'])
        catch
            fprint('No pdf saved for this file')
        end
        
        close (h)
    end
end


